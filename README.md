## Решение профильного задания (React + TypeScript + Redux + VKUI)

В решении задания предполагаю, что групп может быть гораздо больше, чем в моковых данных, поэтому по-хорошему для отображания списка групп нужна пагинация или infinite scroll с подгрузкой новых партий групп через offset и limit, иначе backend может не справиться с выгрузкой всех данных, если их много, а frontend может не справиться с принятием и отрисовкой полученных данных.

В связи с этим показалось логичным, что при изменении состояния фильтров должнен снова осуществляться запрос на backend, который будет отдавать по частям новый набор групп с примененными фильтрами.

Если фильтры применять на стороне frontend-а, то мы можем пойти по сценарию, когда получили, допустим, 12 групп на первую страницу, применили какой-либо фильтр, и на странице не осталось вообще никаких групп, а на вторую подгрузилось снова 12.

Поэтому кнопка "Применить" фильтры отправляет моковый запрос с выбранными опциями фильтров, а имитация работы backend-а в функции mockBackendFiltersResultSet фильтрует занова моковые данные в соответствии с полученными опциями фильтров.

По этой же причине набор цветов аватарок для селекта тоже получаем с backend-а, поскольку для отражения всех возможных цветов на frontend-е понадобятся все группы, поэтому функция mockBackendFilterOptions фильтрует моковые данные и возвращает уникальные цвета аватарок.

## Как запустить проект

1. Установка зависимостей из директории проекта

```bash
npm install
```

1. Для запуска в режиме разработки

```bash
npm run dev
```

## Профильное задание - Frontend-разработчик в команду сообществ

Создайте простое react приложение, состоящее из одной страницы, которое при открытии будет запрашивать список групп с backend (замокайте ответ метода данными из файла `groups.json`).

Типизация ответа метода получения групп `GetGroupsResponse`:

```tsx
interface GetGroupsResponse {
  result: 1 | 0;
  data?: Group[];
}

interface Group {
  id: number;
  name: string;
  closed: boolean;
  avatar_color?: string;
  members_count: number;
  friends?: User[];
}

interface User {
  first_name: string;
  last_name: string;
}
```

- Группа может быть закрытой или открытой.
- Группа может иметь аватарку в виде круга диаметром 100px с заливкой цветом, указанным в атрибуте avatar_color.
- Группа может содержать список ваших друзей, состоящих в ней.

После получения списка всех групп отобразите список на странице в произвольном виде. Отобразите в интерфейсе имя группы, аватарку, тип приватности (закрытая / открытая), кол-во подписчиков и кол-во друзей. При клике на кол-во друзей в блоке группы должен появиться блок с именем и фамилией каждого из друзей.

Если данных для отображения какого-то поля нет, его рисовать не нужно.

Над списком групп должен быть набор фильтров, позволяющий выбрать только нужные нам группы.

Мы должны иметь возможность отфильтровать группы по типу приватности (все / закрытая / открытая), по цвету аватарки (любой / все возможные значения из атрибута avatar_color), наличию друзей в группе

##### Учтите, что backend обрабатывает все запросы с задержкой в 1 секунду. Реализуйте эту задержку самостоятельно.

##### Метод так же может упасть в ошибку или вернуть `result: 0` или не вернуть поле `data`, что равносильно ошибке. Просто учтите это в коде.

Инструмент и метод хранения данных на ваше усмотрение. Никаких ограничений на использование сторонних библиотек.
Вы так же можете воспользоваться любым готовым ui китом, в частности [библиотекой компонентов ВКонтакте](https://www.npmjs.com/package/@vkontakte/vkui) (для удобства обратите внимание на компонент [SimpleCell](https://vkcom.github.io/VKUI/6.0.1/#/SimpleCell))

Результатом тестового задания будет являться проект, доступный по ссылке для проверки.
CSS оцениваться не будет, можно не обращать внимание на визуальную составляющую.
